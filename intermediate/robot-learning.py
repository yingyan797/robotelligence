#########################
# DO NOT EDIT THIS FILE #
#########################

# Imports from external libraries
import numpy as np
import pygame
import torch
import time

# Imports from this project
from environment import Environment
from robot import Robot
from graphics import Graphics


# Set the random seed
seed = int(time.time())
np.random.seed(seed)
torch.manual_seed(seed)
# Initialize Pygame
pygame.init()
# Create an environment (the "physical" world)
environment = Environment()
# Create a robot (the robot's "brain" making the decisions), and give it the forward kinematics model
robot = Robot(environment.forward_kinematics)
# In this exercise, the robot has access to the goal state (so it does not need to learn a reward model)
robot.set_goal_state(environment.goal_state)
# Create a graphics object (this will create a window and draw on the window)
graphics = Graphics()

# Main loop
running = True
while running:
    # Check for any user input
    for event in pygame.event.get():
        # Closing the window
        if event.type == pygame.QUIT:
            running = False
    # Robot selects an action, and decides whether it has finished the episode
    curr_state = np.copy(environment.state)
    action, episode_done = robot.select_action(curr_state)
    # Draw the environment, and any visualisations, on the window
    graphics.draw(environment, robot.planning_visualisation_lines, robot.model_visualisation_lines)
    # If the episode has finished, reset
    if episode_done:
        environment = Environment()
        robot.set_goal_state(environment.goal_state)
        robot.reset()
    # If the episode has not finished, execute the selected action
    else:
        next_state = environment.step(action)
        robot.add_transition(curr_state, action, next_state)

# If we have broken out of the main loop, quite pygame and end the program
pygame.quit()
