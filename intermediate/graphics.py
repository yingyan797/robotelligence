#########################
# DO NOT EDIT THIS FILE #
#########################

# Imports from external libraries
import numpy as np
import pygame

# Imports from this project
import constants
import config


# The Graphics class performs all the pygame drawing
class Graphics:

    # Initialisation of new graphics
    def __init__(self):
        # Screen dimensions
        self.screen = pygame.display.set_mode((3 * config.WINDOW_SIZE + 2 * constants.WINDOW_MARGIN, config.WINDOW_SIZE + constants.WINDOW_HEADER))
        # The three canvasses make up the full window
        self.left_canvas = pygame.Surface((config.WINDOW_SIZE, config.WINDOW_SIZE))
        self.middle_canvas = pygame.Surface((config.WINDOW_SIZE, config.WINDOW_SIZE))
        self.right_canvas = pygame.Surface((config.WINDOW_SIZE, config.WINDOW_SIZE))
        # Set a window title
        pygame.display.set_caption("Robot Learning")
        # Clock to control the frame rate
        self.clock = pygame.time.Clock()

    # Function to draw the environment, and any visualisations, on the window
    def draw(self, environment, planning_visualisation_lines, model_visualisation_lines):
        # Clear the screen
        self.screen.fill((0, 0, 0))
        # Draw the text along the top
        font = pygame.font.SysFont('Arial', 30)
        text_surface = font.render('Environment', True, (255, 255, 255))
        self.screen.blit(text_surface, (0.4 * config.WINDOW_SIZE, 0.2 * constants.WINDOW_HEADER))
        font = pygame.font.SysFont('Arial', 30)
        text_surface = font.render('Planning', True, (255, 255, 255))
        self.screen.blit(text_surface, (1.4 * config.WINDOW_SIZE, 0.2 * constants.WINDOW_HEADER))
        font = pygame.font.SysFont('Arial', 30)
        text_surface = font.render('Model', True, (255, 255, 255))
        self.screen.blit(text_surface, (2.4 * config.WINDOW_SIZE, 0.2 * constants.WINDOW_HEADER))
        # Draw the left panel
        self.left_canvas.fill((0, 0, 0))
        self.draw_border(self.left_canvas)
        self.draw_environment(environment, self.left_canvas)
        self.draw_goal_state(environment, self.left_canvas)
        self.draw_robot(environment, self.left_canvas)
        # Draw the middle panel
        self.middle_canvas.fill((0, 0, 0))
        self.draw_border(self.middle_canvas)
        self.draw_environment(environment, self.middle_canvas)
        self.draw_goal_state(environment, self.middle_canvas)
        self.draw_robot(environment, self.middle_canvas)
        # Draw the right panel
        self.right_canvas.fill((0, 0, 0))
        self.draw_border(self.right_canvas)
        # Draw the visualisations
        self.draw_visualisation_lines(planning_visualisation_lines, model_visualisation_lines)
        # Send the panels to the window
        self.screen.blit(self.left_canvas, (0, constants.WINDOW_HEADER))
        self.screen.blit(self.middle_canvas, (config.WINDOW_SIZE + constants.WINDOW_MARGIN, constants.WINDOW_HEADER))
        self.screen.blit(self.right_canvas, (2 * config.WINDOW_SIZE + 2 * constants.WINDOW_MARGIN, constants.WINDOW_HEADER))
        # Update the display
        pygame.display.flip()
        # Tick the clock, i.e. wait for one step of the environment
        self.clock.tick(config.FRAME_RATE)

    # Function to draw the environment
    def draw_environment(self, environment, canvas):
        # Draw the obstacle
        position = self.world_pos_to_window_pos(environment.obstacle_pos)
        radius = self.world_len_to_window_len(environment.obstacle_radius)
        pygame.draw.circle(canvas, constants.OBSTACLE_COLOUR, position, radius)

    # Function to draw the panel border
    def draw_border(self, canvas):
        pygame.draw.rect(canvas, (200, 200, 200), pygame.Rect(0, 0, config.WINDOW_SIZE, config.WINDOW_SIZE), 5)

    # Function to draw the initial and goal states
    def draw_goal_state(self, environment, canvas):
        # Draw the goal state
        position = self.world_pos_to_window_pos(environment.goal_state)
        radius = self.world_len_to_window_len(constants.GOAL_RADIUS)
        pygame.draw.circle(canvas, constants.GOAL_COLOUR, position, radius)

    # Function to draw the robot
    def draw_robot(self, environment, canvas):
        # Calculate the positions of the joints
        robot_joint_pos = environment.forward_kinematics(environment.state)
        base_pos = self.world_pos_to_window_pos(environment.robot_base_pos)
        joint1_pos = self.world_pos_to_window_pos(robot_joint_pos[0])
        joint2_pos = self.world_pos_to_window_pos(robot_joint_pos[1])
        hand_pos = self.world_pos_to_window_pos(robot_joint_pos[2])
        # Draw the lines for the links
        link_colour = constants.ROBOT_LINK_COLOUR
        link_width = self.world_len_to_window_len(constants.ROBOT_LINK_WIDTHS[0])
        pygame.draw.line(canvas, link_colour, base_pos, joint1_pos, link_width)
        link_width = self.world_len_to_window_len(constants.ROBOT_LINK_WIDTHS[1])
        pygame.draw.line(canvas, link_colour, joint1_pos, joint2_pos, link_width)
        link_width = self.world_len_to_window_len(constants.ROBOT_LINK_WIDTHS[2])
        pygame.draw.line(canvas, link_colour, joint2_pos, hand_pos, link_width)
        # Draw the base
        base_left = np.copy(environment.robot_base_pos)
        base_left[0] -= 0.5 * constants.ROBOT_BASE_LENGTH
        base_left = self.world_pos_to_window_pos(base_left)
        base_right = np.copy(environment.robot_base_pos)
        base_right[0] += 0.5 * constants.ROBOT_BASE_LENGTH
        base_right = self.world_pos_to_window_pos(base_right)
        base_width = self.world_len_to_window_len(constants.ROBOT_BASE_WIDTH)
        base_colour = constants.ROBOT_BASE_COLOUR
        pygame.draw.line(canvas, base_colour, base_left, base_right, base_width)
        # Draw the circles for the joints and hand
        joint1_radius = self.world_len_to_window_len(constants.ROBOT_JOINT_RADIUS)
        joint1_colour = constants.ROBOT_JOINT_COLOUR
        pygame.draw.circle(canvas, joint1_colour, joint1_pos, joint1_radius)
        joint2_radius = self.world_len_to_window_len(constants.ROBOT_JOINT_RADIUS)
        joint2_colour = constants.ROBOT_JOINT_COLOUR
        pygame.draw.circle(canvas, joint2_colour, joint2_pos, joint2_radius)
        hand_radius = self.world_len_to_window_len(constants.ROBOT_HAND_RADIUS)
        hand_colour = constants.ROBOT_HAND_COLOUR
        pygame.draw.circle(canvas, hand_colour, hand_pos, hand_radius)

    # Function to draw any visualisation lines
    def draw_visualisation_lines(self, planning_visualisation_lines, model_visualisation_lines):
        # Planning
        for visualisation in planning_visualisation_lines:
            # For each visualisation, get the attributes necessary to create a pygame line
            start_pos = self.world_pos_to_window_pos([visualisation.x1, visualisation.y1])
            end_pos = self.world_pos_to_window_pos([visualisation.x2, visualisation.y2])
            width = self.world_len_to_window_len(visualisation.width)
            pygame.draw.line(self.middle_canvas, visualisation.colour, start_pos, end_pos, width)
        # Model
        for visualisation in model_visualisation_lines:
            # For each visualisation, get the attributes necessary to create a pygame line
            start_pos = self.world_pos_to_window_pos([visualisation.x1, visualisation.y1])
            end_pos = self.world_pos_to_window_pos([visualisation.x2, visualisation.y2])
            width = self.world_len_to_window_len(visualisation.width)
            pygame.draw.line(self.right_canvas, visualisation.colour, start_pos, end_pos, width)

    # Function to draw any visualisation circles
    def draw_visualisation_circles(self, visualisation_circles):
        for visualisation in visualisation_circles:
            # Get the panel/canvas
            if visualisation.panel == 'left':
                canvas = self.left_canvas
            elif visualisation.panel == 'middle':
                canvas = self.middle_canvas
            elif visualisation.panel == 'right':
                canvas = self.right_canvas
            else:
                raise Exception("visualisation.panel must be either 'left', 'middle', or 'right.")
            # For each visualisation, get the attributes necessary to create a pygame circle
            centre = self.world_pos_to_window_pos([visualisation.x, visualisation.y])
            radius = self.world_len_to_window_len(visualisation.radius)
            colour = visualisation.colour
            pygame.draw.circle(canvas, colour, centre, radius)

    # Function to covert a position in world/environment space, to a position in pixels on the window
    def world_pos_to_window_pos(self, world_pos):
        window_pos_x = int(config.WINDOW_SIZE * world_pos[0])
        window_pos_y = int(config.WINDOW_SIZE - config.WINDOW_SIZE * world_pos[1])
        return [window_pos_x, window_pos_y]

    # Function to convert a length in world/environment space, to a length in pixels on the window
    def world_len_to_window_len(self, world_length):
        window_length = int(config.WINDOW_SIZE * world_length)
        return window_length
